установить зависимости Node.js:
npm install

Запуск генерации грамматики:
npx tree-sitter generate

src- исходники парсера

Конвертировать файл на языке mylang в S-expression формате в файл:
tree-sitter parse input.mylang > ast.sexp










Промпт:

Использовать средство синтаксического анализа по выбору, реализовать модуль для разбора текста в
соответствии с языком по варианту. Реализовать построение по исходному файлу с текстом синтаксического
дерева с узлами, соответствующими элементам синтаксической модели языка. Вывести полученное дерево в
файл в формате, поддерживающем просмотр графического представления.

был выбран tree-setter



Изучить синтаксис разбираемого по варианту языка и записать спецификацию для средства
синтаксического анализа, включающую следующие конструкции:
a. Подпрограммы со списком аргументов и возвращаемым значением
b. Операции контроля потока управления – простые ветвления if-else и циклы или аналоги
c. В зависимости от варианта – определения переменных
d. Целочисленные, строковые и односимвольные литералы
e. Выражения численной, битовой и логической арифметики
f. Выражения над одномерными массивами
g. Выражения вызова функции
3. Реализовать модуль, использующий средство синтаксического анализа для разбора языка по варианту
   a. Программный интерфейс модуля должен принимать строку с текстом и возвращать структуру,
   описывающую соответствующее дерево разбора и коллекцию сообщений ошибке
   b. Результат работы модуля – дерево разбора – должно содержать иерархическое
   представление для всех синтаксических конструкций, включая выражения, логически
   представляющие собой иерархически организованные данные, даже если на уровне средства
   синтаксического анализа для их разбора было использовано линейное представление
4. Реализовать тестовую программу для демонстрации работоспособности созданного модуля
   a. Через аргументы командной строки программа должна принимать имя входного файла для
   чтения и анализа, имя выходного файла записи для дерева, описывающего синтаксическую
   структуру разобранного текста
   b. Сообщения об ошибке должны выводиться тестовой программной (не модулем, отвечающим
   за анализ!) в стандартный поток вывода ошибок



Общая часть синтаксической модели для всех вариантов:
identifier: "[a-zA-Z_][a-zA-Z_0-9]*"; // идентификатор
str: "\"[^\"\\]*(?:\\.[^\"\\]*)*\""; // строка, окруженная двойными кавычками
char: "'[^']'"; // одиночный символ в одинарных кавычках
hex: "0[xX][0-9A-Fa-f]+"; // шестнадцатеричный литерал
bits: "0[bB][01]+"; // битовый литерал
dec: "[0-9]+"; // десятичный литерал
bool: 'true'|'false'; // булевский литерал
list<item>: (item (',' item)*)?; // список элементов, разделённых запятыми


source: sourceItem*;
typeRef: {
|builtin: 'bool'|'byte'|'int'|'uint'|'long'|'ulong'|'char'|'string';
|custom: identifier;
|array: typeRef 'array' '[' dec ']'; // число - размерность
};
funcSignature: identifier '(' list<arg> ')' ('of' typeRef)? {
arg: identifier ('of' typeRef)?;
};
sourceItem: {
|funcDef: 'def' funcSignature statement* 'end';
};
statement: { // присваивание через '='
|if: 'if' expr 'then' statement ('else' statement)?;
|loop: ('while'|'until') expr statement* 'end';
|repeat: statement ('while'|'until') expr ';';
|break: 'break' ';';
|expression: expr ';';
|block: ('begin'|'{') (statement|sourceItem)* ('end'|'}');
};
expr: {
|binary: expr binOp expr; // где binOp - символ бинарного оператора
|unary: unOp expr; // где unOp - символ унарного оператора
|braces: '(' expr ')';
|call: expr '(' list<expr> ')';
|slice: expr '[' list<range> ']' { // индексация или срез массива
ranges: expr ('..' expr)?; // from index, to
};
|place: identifier;
|literal: bool|str|char|hex|bits|dec;
};

мне нужно написать

grammar.js


и input.mylang для входных данных







